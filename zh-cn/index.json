[{"categories":[""],"content":"介绍背包九讲中的 0-1背包，完全背包，多重背包问题。\n0-1 背包 $n$ 个物品，第 $i$ 个物品体积为 $v_i$， 价值为 $w_i$ 。给你一个容量为 $C$ 的背包，求装入背包的物品总价值最大是多少？\n解答 令 $dp[i][j]$ 表示拿第 $i$ 个物品，体积为 $j$ 时的最大值\n$dp[i][j] = \\max(dp[i-1][j-v[i]]+w[i],dp[i-1][j])$\n由于每个 $dp[i][\\cdot]$ 只与 $dp[i-1][\\cdot]$ 有关，故直接用一维数组保存即可\n复杂度 $\\mathcal{O} (n^2)$\n1for(int i = 1; i \u0026lt;= n; i++) { 2 for(int j = C; j \u0026gt;= v[i]; j--) { 3 dp[j] = max(dp[j-v[i]]+w[i], dp[j]); 4 } 5} 完全背包 $n$ 种物品，每种物品无穷个，第 $i$ 种物品体积为 $v_i$， 价值为 $w_i$ 。给你一个容量为 $C$ 的背包，求装入背包的物品总价值最大是多少？\n解答 令 $dp[i][j]$ 表示拿第 $i$ 种物品，体积为 $j$ 时的最大值\n$dp[i][j] = \\max(dp[i-1][j-k\\cdot v[i]]+k\\cdot w[i])$ 其中 $k$ 为第 $i$ 种物品拿的个数\n由于每个 $dp[i][\\cdot]$ 只与 $dp[i-1][\\cdot]$ 有关，故直接用一维数组保存即可\n复杂度 $\\mathcal{O} (n^2)$\n1for(int i = 1; i \u0026lt;= n; i++) { 2 for(int j = v[i]; j \u0026lt;= C; j++) { 3 dp[j] = max(dp[j-v[i]]+w[i], dp[j]); 4 } 5} 多重背包 $n$ 种物品，第 $i$ 种物品个数为 $s_i$，体积为 $v_i$， 价值为 $w_i$ 。给你一个容量为 $C$ 的背包，求装入背包的物品总价值最大是多少？\n解答 令 $dp[i][j]$ 表示拿第 $i$ 种物品，体积为 $j$ 时的最大值\n$dp[i][j] = \\max(dp[i-1][j-k\\cdot v[i]]+k\\cdot w[i]),\\ (0\\leq k\\leq s_i)$ 其中 $k$ 为第 $i$ 种物品拿的个数\n由于每个 $dp[i][\\cdot]$ 只与 $dp[i-1][\\cdot]$ 有关，故直接用一维数组保存即可\n将其转化为 0-1 背包 直接算复杂度为 $\\mathcal O(n\\sum_{i=1}^{n} s_i)$，下面介绍几种优化\n二进制优化 可以将 $s_i$ 件物品拆分成 $1,2,4,8,\\cdots,2^{k-1},s_i-2^{k}+1$ 件物品的组合。例如价值为 $3$，体积为 $4$，数量为 $10$ 的物品，可以拆成 $1+2+4+3$ 转化为价值为 $(3,6,12,8)$，体积为 $(4,8,16,12)$ 数量均为 $1$ 的 $4$ 件物品。每个 $s_i$ 都能转化成 $\\lceil \\log_2(s_i+1) \\rceil$ 件物品，再利用 0-1 背包 求解即可。\n**为何这样转换之后答案仍然对呢？**这是因为 $\\forall x\\in[0,s_i]$，总可以由 $s_i$ 件物品转化成的 $\\lceil \\log_2(s_i+1) \\rceil$ 件物品的某个组合得到。以上例说明：$10$ 拆成 $1+2+4+3$。那么有 $$ 0=0, 1=1, 2=2, 3=3, 4=4, 5=1+4 , 6=2+4 \\\\ 7=1+2+4,8=1+4+3,9=2+4+3,10=1+2+3+4 $$\n复杂度 $\\mathcal O(n^2\\log_2 n)$\n1for(int i = 1; i \u0026lt;= n; i++) { //第 i 个物品 2 for(int k = 1; s[i]; s[i] -= k, k = min(k\u0026lt;\u0026lt;1, s[i])) { //二进制优化 3 for(int j = C; j \u0026gt;= k*v[i]; j--) { 4 dp[j] = max(dp[j-k*v[i]] + k*w[i], dp[j]); 5 } 6 } 7} 单调队列优化 对于每种物品都有\n$dp[j] = \\max(dp[j-v]+w,dp[j-2v]+2w,\\cdots,dp[j-sv]+sw)$\n$dp[j+v] = \\max(dp[j]+w,dp[j-v]+2w,dp[j-2v]+3w,\\cdots,dp[j-(s-1)v]+sw)$\n可以看出 $dp[j]$ 后面的 $max$ 求值和 $dp[j+v]$ 的 $max$ 求值是有重复的，所有项全都加上一个 $w$ 最大值不变。只要对两端的项再处理一下即可。\n复杂度 $\\mathcal{O} (n^2)$\n1for(int i = 1; i \u0026lt;= n; i++) { //第 i 种物品 2 for(int k = 0; k \u0026lt; v[i]; k++) { //余数从 0 to v[j]-1 3 deque\u0026lt;Pack\u0026gt; Q; //单调递减队列 4 for(int j = k, ord = 1; j \u0026lt;= C; j+=v[i], ord++) { //dp[j] 为 j 容量的背包最大价值 5 int value = dp[j] - ord*w[i]; 6 while(!Q.empty() \u0026amp;\u0026amp; Q.back().value \u0026lt;= value) Q.pop_back(); 7 Q.push_back(Pack(value, ord)); 8 if(ord - Q.front().order \u0026gt; s[i]) Q.pop_front(); //个数超出 9 dp[j] = Q.front().value + ord*w[i]; 10 } 11 } 12} ","date":"2021-12-07","img":"","permalink":"/zh-cn/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","series":null,"tags":["动态规划"],"title":"背包九讲-前三讲"},{"categories":["HTML"],"content":"介绍Markdown的一些字处理，包括字体、颜色、背景颜色、大小、排版。\n1 字体颜色 1\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;红色\u0026lt;/font\u0026gt; 红色\n2 字体 1\u0026lt;font face=\u0026#34;STCAIYUN\u0026#34;\u0026gt;华文彩云\u0026lt;/font\u0026gt; 华文彩云\n3 字体大小 1\u0026lt;font size=\u0026#34;5\u0026#34;\u0026gt;我的大小为5哦\u0026lt;/font\u0026gt; 我的大小为5哦我是正常尺寸\n4 字体背景颜色 1\u0026lt;font style=\u0026#34;background:red\u0026#34;\u0026gt;我有黄颜色背景\u0026lt;/font\u0026gt; 2\u0026lt;font style=\u0026#34;background-color:red\u0026#34;\u0026gt;我有黄颜色背景\u0026lt;/font\u0026gt; 我有黄颜色背景\n5 CSS-Style 代替font标签 1\u0026lt;span style=\u0026#34;color:red; background-color:yellow; font-size: 22pt; font-family:STCAIYUN;\u0026#34;\u0026gt;Lunat\u0026lt;/span\u0026gt; Lunat\n6 文本居中 1\u0026lt;p style=\u0026#34;text-align:center;\u0026#34;\u0026gt;我在中间\u0026lt;/p\u0026gt; 我在中间\n7 mark 文本 1\u0026lt;mark\u0026gt;mark文本\u0026lt;/mark\u0026gt; mark文本\n","date":"2021-11-30","img":"","permalink":"/zh-cn/posts/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/","series":null,"tags":null,"title":"Markdown文本处理"},{"categories":["temp"],"content":"本文档用于临时记录数理统计理论篇考试习题。\n理论篇（40分） 第一题  考随机变量及其分布\n 给出随机变量的概率密度 $$ f(x) = \\begin{cases} \\cfrac{2x}{\\pi^2}, \u0026amp; 0\u0026lt;x\u0026lt;\\pi \\\\[1ex] 0, \u0026amp; others \\end{cases} $$\n1. 求出分布函数 求连续型随机变量的分布函数，实际上就是求这个式子的值：$F(x) = \\int_{-\\infty}^x f(t)dt\\ (x\\in \\mathbf R)$，这是我们高数的变限积分。\n例1(上课的例子) ： $$ f(x) = \\begin{cases} \\cfrac{2x}{\\pi^2}, \u0026amp; 0\u0026lt;x\u0026lt;\\pi \\\\[1ex] 0, \u0026amp; others \\end{cases} $$\n当 $x\\in(-\\infty,0)$ 时，有 $$ F(x) = \\int_{-\\infty}^x 0dx = 0 $$ 当 $x\\in[\\ 0,\\pi)$ 时，有 $$ \\begin{align*} F(x) = \\int_{-\\infty}^0 0dx + \\int_{0}^x \\frac{2x}{\\pi^2}dx = \\frac{x^2}{\\pi^2}\\Bigg|_0^x =\\cfrac{x^2}{\\pi^2} \\end{align*} $$ 当 $x\\in[\\ \\pi,+\\infty)$ 时，有 $$ F(x) = \\int_{-\\infty}^0 0dx + \\int_{0}^\\pi \\frac{2x}{\\pi^2}dx +\\int_{\\pi}^{x} 0dx = 1 $$ 故\n$$ F(x) = \\begin{cases} 0, \u0026amp;x\u0026lt;0 \\\\ \\cfrac{x^2}{\\pi^2} , \u0026amp;0\\leq x \u0026lt;\\pi \\\\ 1, \u0026amp; x \\geq \\pi \\end{cases} $$\n 注意 自变量 $x$ 的分段小区间除第一个区间外，尽量写成左闭右开的\n 2. 分析随机变量是连续的还是离散的  这里注意考试凡概率密度一定是连续的，离散的那个叫概率分布。\n 下面是正解：\n如果随机变量 $X$ 的分布函数可以写成 $$ F(x) = \\int_{-\\infty}^x f(t)dt\\ (x\\in \\mathbf R) $$\n也就是一个变限积分，且处处连续可微，那么就是连续型随机变量。其中 $f(x)$ 是概率密度函数。（这里的连续型随机变量并不要求整个 $f(x)$ 在实数域上连续，而是要求 $F(x)$ 是连续型函数，$f(x)$ 除了有限个点外是连续的，且 $f(x) = F'(x)$ )\n3. 用概率空间的思想解释分布函数与随机变量 先来讲一下怎么理解概率空间 $(\\Omega,\\mathcal F,P)$ ，给大家拆分一下， $\\Omega$ 是个集合（样本空间），集合里包含了所有的基本事件，$\\mathcal F$ 也是个集合，他是 $\\Omega$ 所有子集的集合，所以是集合的集合。$P$ 代表函数，对于$\\mathcal F$ 中的每个元素 $E$，都有一个 $P(E)$ ，代表 事件 $E$ 的概率（发生可能性）。\n举个例子，对于扔硬币:\n$\\Omega = \\lbrace 正面，反面\\rbrace$\n$\\mathcal F = \\lbrace \\lbrace正面，反面\\rbrace， \\lbrace正面\\rbrace， \\lbrace反面\\rbrace，\\varnothing\\rbrace$ $P( \\lbrace正面，反面\\rbrace) = 1;\\ P( \\lbrace正面\\rbrace)= 0.5；P( \\lbrace反面\\rbrace) = 0.5,P(\\varnothing) = 0$\n这就是扔一次硬币的概率空间。\n那么随机变量和分布函数与这个概率空间有什么关系呢？\n随机变量代表的就是 $\\Omega$ 中的基本事件。比如随机变量在”扔一次硬币实验“中 $X = 1$ 可以代表 正面，$X=0$ 代表反面。\n概率空间就变成了以下：\n$\\Omega = \\lbrace1，0\\rbrace$\n$\\mathcal F = \\lbrace\\lbrace1，0\\rbrace，\\lbrace1\\rbrace，\\lbrace0\\rbrace, \\varnothing\\rbrace$\n$P(\\lbrace1，0\\rbrace) = 1;\\ P(\\lbrace1\\rbrace)= 0.5；P(\\lbrace0\\rbrace) = 0.5, P(\\varnothing) = 0$\n所以随机变量实际上就是把基本事件数值化的函数，数值化之后数学才能研究的下去。\n概率分布函数实际上是关于随机变量 $X$ 与 $P$ 的函数 $F(x) = P(X\\leq x)$ ，可以看到 $F(x)$ 只描述了 $P(X\\in(-\\infty,x))$ 可见将 $x=+\\infty， F(+\\infty) = 1$ 即代表所有基本事件概率的和 $P(X\\in(-\\infty,+\\infty))$。 分布函数将所有基本事件集中起来，可以描述复合事件的概率，最大值是1——必然事件。\n总结$(F(-\\infty), F(+\\infty))$ 代表 概率空间其概率测度为 $[,0,1,]$，概率空间总测试为 $1$，即 $F(+\\infty) = P(\\Omega) = 1$，$F(x)$ 代表概率空间中 $\\mathcal F$（事件集合）的 子集 $\\lbrace\\omega \\mid X(w)\\leq x\\rbrace$ 的概率 $P$，而随机变量 $X$ 代表 概率空间中样本空间 $\\Omega$ 中的基本事件。\n4. 把连续的随机变量变成离散的随机变量  就是把连续型随机变量的概率密度离散成离散型随机变量的概率分布\n $$ f(x) = \\begin{cases} \\cfrac{2x}{\\pi^2}, \u0026amp; 0\u0026lt;x\u0026lt;\\pi \\\\[1ex] 0, \u0026amp; others \\end{cases} $$\n可以将概率密度函数有值的那部分 $0\u0026lt;x\u0026lt;\\pi$ 离散成 $3$ 份的区间 $(0,\\frac {\\pi}{3}),(\\frac {\\pi}{3},\\frac {2\\pi}{3}),(\\frac {2\\pi}{3},\\pi)$，每个区间取中间值来构造离散随机变量 $X$ 。 $X = X_i$ 就代表第 $i$ 个区间， 第 $i$ 个区间的概率就是 $P(X = X_i)$ ，写成概率分布如下 $$ \\begin{array}{c|ccc} X \u0026amp; \\cfrac 16\\cdot \\pi \u0026amp; \\cfrac 36\\cdot \\pi \u0026amp; \\cfrac 56\\cdot \\pi \\\\ \\hline P \u0026amp; \\cfrac 19 \u0026amp; \\cfrac 39 \u0026amp; \\cfrac 59 \\end{array} $$\n第二题 黎曼-斯蒂尔切期积分 黎曼积分\n根据定义分析哪个更好 好在什么情况下\n第三题 构造一个随机变量，求其随机变量序列收敛性\n第四题 求参数估计中的似然函数\n 最大似然函数 求对数似然函数  这两个都有可能（考试出一个）\n","date":"2021-11-28","img":"","permalink":"/zh-cn/posts/%E5%BA%94%E7%94%A8%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80/","series":null,"tags":["Math"],"title":"应用数理统计理论篇考试教程"},{"categories":["MISC"],"content":"用来求解 r=a*b%p 中的 a*b 超过 long long 范围导致爆 long long 的算法，其中 a，b，p，r 均为 long long 类型\n传统上我们可以仿照 快速幂 来进行快速乘\n复杂度 $\\mathcal{O}{(\\log_2^n)}$\n1typedef long long ll; 2ll qm(ll a, ll b, ll p) //qm = quick multiply; a * b % p 3{ 4 if(!b) return 0; 5 if(b\u0026amp;1) return (a+qm(2*a%p, b\u0026gt;\u0026gt;1, p)) % p; 6 else return qm(2*a%p, b\u0026gt;\u0026gt;1, p) % p; 7} 另一种方法 是利用计算机的性质，和一些求模性质\n求 a*b%p 时，我们引进一个模数 $m$ 满足 $(m\u0026gt;p)$，有以下公式成立\n$$ \\begin{align*}a\\cdot b \\bmod p \u0026amp;= a\\cdot b - p\\cdot\\lfloor\\frac{a\\cdot b}{p}\\rfloor = (a\\cdot b - p\\cdot\\lfloor\\frac{a\\cdot b}{p}\\rfloor)\\bmod m \\newline \u0026amp;= (a\\cdot b \\bmod m -p \\cdot \\lfloor\\frac{a}{p}\\cdot b\\rfloor\\bmod m)\\bmod m \\end{align*} $$\n显然这个 $m$ 可以是 long long 表示的范围大小 $2^{64}$，而计算机中两个 long long 类型的数据做算术运算是隐式求余 $2^{64}$ 的，其求余结果在 $[-2^{63}, 2^{63}-1]$ 之间，由于 $p$ 用 long long 表示，则 $p\u0026lt;m/2$，上述计算式结果必为正，在计算机中所有 $\\bmod m$ 都可以直接去掉，而不会影响结果的正确性。\n1typedef long long ll; 2ll qm(ll a, ll b, ll p) 3{ 4 return a*b - p*(ll)((long double)a/p*b); 5} 假如不考虑浮点数精度问题，以上代码则可直接求出 a*b%p 的准确值，但是 long double 并不能很好的表示整数部分。其整数部分会产生 -1, +1, 0 三类的偏差。比如 $5$ 被表示成 $4.99999\\cdots$ 其整数部分少了$1$，$1.9999999999\\cdots$ 表示成 $2.000000000$，其整数部分多了 $1$，反映到结果上有：\n$p\\cdot\\lfloor\\frac{a}{p}\\cdot b\\rfloor\\bmod m \\to p\\cdot(\\lfloor\\frac{a}{p}\\cdot b\\rfloor + x)\\bmod m,\\ x\\in(-1,0,1) $\n显然无论 $x$ 取何值，结果 $\\bmod \\ p$ 都是不变的，假设正确答案是 $rest$ 那么上述代码得到的结果为\n$(rest+p\\cdot x)\\bmod 2^{64},\\ x\\in(-1,1,0),\\ rest\\in[0,p-1]$\n模 $2^{64}$ 在计算机中不是表示成 $[0, 2^{64}-1]$ 而是表示成 $[-2^{63}, 2^{63}-1]$\n所以当 $x$ 为 $-1$ 时 上述代码变成了个负数，结果出错，需 +p 后为正确答案\n$x$ 为 $1$ 时，$rest + p\\cdot x$ 当 $p\\leqslant \\frac m4$ 时在计算机中表示为正数，当 $\\frac m4 \u0026lt; p \u0026lt; \\frac m2$ 时在计算机中表示为负数，比如 rest = 6e18, p = 7e18+1 此时 $rest+p$ 在计算机中 rest + p = -5446744073709551616\n总结，无论 $x$ 为 $-1,0,1$ ，若结果为负则 +p 即可，若结果为正则 %p 即可\n复杂度 $\\mathcal{O}(1)$\n1typedef long long ll; 2ll qm(ll a, ll b, ll p) 3{ 4 a%=p, b%=p; 5 ll r = a*b - (ll)((long double)a/p*b)*p; 6 return r \u0026lt; 0 ? r+p : r%p; 7} 讨论 代码中 a%=p, b%=p 的必要性，当 long double 能够表示 $\\lfloor\\frac{a}{p}\\cdot b\\rfloor$，则不必要。易知，其实对于超过 int 大小的 p 都不必加上求余。\n","date":"2021-09-05","img":"","permalink":"/zh-cn/posts/%E5%BF%AB%E9%80%9F%E4%B9%98/","series":["底层优化"],"tags":["Math"],"title":"快速乘"},{"categories":["数论"],"content":"$x$ 满足 $a\\cdot x \\equiv 1 \\pmod{m} $ ; $x$ 称之为 $a$ 对模 $m$ 的逆，记作 $a^{-1}$\n性质  若 $\\gcd(a, m) = 1$ $\\iff$ $a$ 在模 $m$ 下有逆元  逆元的求解 扩展欧几里得算法 设 $a\\cdot x + m\\cdot y = 1$\n$a\\cdot x = 1-m\\cdot y \\equiv 1 \\pmod m$\n$x$ 是 $a$ 对 $m$ 的逆元，问题转化为求方程 $a\\cdot x + m\\cdot y = 1$ 的正整数解\n$\\gcd(a,m) = 1$ 方程必有解，扩展欧几里得算法跑一下方程，求出 $x$ 再模 $p$ 处理\n复杂度 $\\mathcal{O}(\\log_2^n)$\n1int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) 2{ 3 if(!b) { x = 1; y = 0; return a; } 4 int g = exgcd(b, a%b, y, x); 5 y -= a/b*x; 6 return g; 7} 费马小定理 $\\tau(p)=2,\\ \\gcd(a,p) =1 \\implies a^{p-1}\\equiv 1 \\pmod p$\n$a*a^{p-2} \\equiv 1\\pmod p,\\ a$ 在模 $p$ 下的逆元为 $a^{p-2}$\n快速幂求 $a^{p-2}$ 即可\n复杂度 $\\mathcal{O}(\\log_2^n)$\n1int qp(int a, int b, int p) //qp = quick power 2{ 3 if(!b) return 1; 4 if(b\u0026amp;1) return a*qp(a*a%p, b\u0026gt;\u0026gt;1, p)%p; 5 else return qp(a*a%p, b\u0026gt;\u0026gt;1, p)%p; 6} 7int ie = qp(a, p-2, p); //ie = inverse element Fermat-Euler 定理 $\\gcd(a,m) = 1$ 时 $a^{\\varphi(m)} \\equiv 1 \\pmod m$\n所以 $a^{\\varphi(m)-1}$ 是 $a$ 在模 $m$ 下的逆元\n需要求 $\\varphi(m)$，再用快速幂求 $a^{\\varphi(m)-1}$\n不推荐\n线性递推 求 $\\forall{a},a\\in[1,p-1]$ ，模 $p$ 的逆元\n令 $ax + b = p;\\ b\\cdot b^{-1} \\equiv 1 \\pmod p$\n$\\because b = p-ax$\n$\\therefore (p-ax)\\cdot b^{-1} \\equiv 1 \\pmod p \\implies a\\cdot(-x\\cdot b^{-1}) \\equiv 1 \\pmod p$\n$\\therefore a^{-1}\\equiv (-x\\cdot b^{-1}) \\equiv (p-x)\\cdot b^{-1} \\pmod p$\n$a \u0026gt; b$ 直接动态规划扫一遍就好了\n在计算机中 $b$ 表示为 p%a，$x$ 表示为 p/a\n复杂度 $\\mathcal{O}(n)$\n1int inv[p] = {0, 1}; //inv = inverse element 2for(int i = 2; i \u0026lt; p; i++){ 3 inv[i] = (p-p/i) * inv[p%i] % p; 4} ","date":"2021-09-04","img":"","permalink":"/zh-cn/posts/%E9%80%86%E5%85%83/","series":null,"tags":["逆元"],"title":"逆元"}]