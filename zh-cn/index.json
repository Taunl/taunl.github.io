[{"categories":["MISC"],"content":"用来求解 r=a*b%p 中的 a*b 超过 long long 范围导致爆 long long 的算法，其中 a，b，p，r 均为 long long 类型\n传统上我们可以仿照 快速幂 来进行快速乘\n复杂度 $\\mathcal{O}{(\\log_2^n)}$\n1typedef long long ll; 2ll qm(ll a, ll b, ll p) //qm = quick multiply; a * b % p 3{ 4 if(!b) return 0; 5 if(b\u0026amp;1) return (a+qm(2*a%p, b\u0026gt;\u0026gt;1, p)) % p; 6 else return qm(2*a%p, b\u0026gt;\u0026gt;1, p) % p; 7} 另一种方法 是利用计算机的性质，和一些求模性质\n求 a*b%p 时，我们引进一个模数 $m$ 满足 $(m\u0026gt;p)$，有以下公式成立\n$$ \\begin{align}a\\cdot b \\bmod p \u0026amp;= a\\cdot b - p\\cdot\\lfloor\\frac{a\\cdot b}{p}\\rfloor = (a\\cdot b - p\\cdot\\lfloor\\frac{a\\cdot b}{p}\\rfloor)\\bmod m \\newline \u0026amp;= (a\\cdot b \\bmod m -p \\cdot \\lfloor\\frac{a}{p}\\cdot b\\rfloor\\bmod m)\\bmod m \\end{align} $$\n显然这个 $m$ 可以是 long long 表示的范围大小 $2^{64}$，而计算机中两个 long long 类型的数据做算术运算是隐式求余 $2^{64}$ 的，其求余结果在 $[-2^{63}, 2^{63}-1]$ 之间，由于 $p$ 用 long long 表示，则 $p\u0026lt;m/2$，上述计算式结果必为正，在计算机中所有 $\\bmod m$ 都可以直接去掉，而不会影响结果的正确性。\n1typedef long long ll; 2ll qm(ll a, ll b, ll p) 3{ 4 return a*b - p*(ll)((long double)a/p*b); 5} 假如不考虑浮点数精度问题，以上代码则可直接求出 a*b%p 的准确值，但是 long double 并不能很好的表示整数部分。其整数部分会产生 -1, +1, 0 三类的偏差。比如 $5$ 被表示成 $4.99999\\cdots$ 其整数部分少了$1$，$1.9999999999\\cdots$ 表示成 $2.000000000$，其整数部分多了 $1$，反映到结果上有：\n$p\\cdot\\lfloor\\frac{a}{p}\\cdot b\\rfloor\\bmod m \\to p\\cdot(\\lfloor\\frac{a}{p}\\cdot b\\rfloor + x)\\bmod m,\\ x\\in(-1,0,1) $\n显然无论 $x$ 取何值，结果 $\\bmod p$ 都是不变的，假设正确答案是 $rest$ 那么上述代码得到的结果为\n$(rest+p\\cdot x)\\bmod 2^{64},\\ x\\in(-1,1,0),\\ rest\\in[0,p-1]$\n模 $2^{64}$ 在计算机中不是表示成 $[0, 2^{64}-1]$ 而是表示成 $[-2^{63}, 2^{63}-1]$\n所以当 $x$ 为 $-1$ 时 上述代码变成了个负数，结果出错，需 +p 后为正确答案\n$x$ 为 $1$ 时，$rest + p\\cdot x$ 当 $p\\leqslant \\frac m4$ 时在计算机中表示为正数，当 $\\frac m4 \u0026lt; p \u0026lt; \\frac m2$ 时在计算机中表示为负数，比如 rest = 6e18, p = 7e18+1 此时 $rest+p$ 在计算机中 rest + p = -5446744073709551616\n总结，无论 $x$ 为 $-1,0,1$ ，若结果为负则 +p 即可，若结果为正则 %p 即可\n复杂度 $\\mathcal{O}(1)$\n1typedef long long ll; 2ll qm(ll a, ll b, ll p) 3{ 4 a%=p, b%=p; 5 ll r = a*b - (ll)((long double)a/p*b)*p; 6 return r \u0026lt; 0 ? r+p : r%p; 7} 讨论 代码中 a%=p, b%=p 的必要性，当 long double 能够表示 $\\lfloor\\frac{a}{p}\\cdot b\\rfloor$，则不必要。易知，其实对于超过 int 大小的 p 都不必加上求余。\n","date":"2021-09-05","img":"","permalink":"/zh-cn/posts/%E5%BF%AB%E9%80%9F%E4%B9%98/","series":["底层优化"],"tags":["Math"],"title":"快速乘"},{"categories":["数论"],"content":"$x$ 满足 $a\\cdot x \\equiv 1 \\pmod{m} $ ; $x$ 称之为 $a$ 对模 $m$ 的逆，记作 $a^{-1}$\n性质  若 $\\gcd(a, m) = 1$ $\\iff$ $a$ 在模 $m$ 下有逆元  逆元的求解 扩展欧几里得算法 设 $a\\cdot x + m\\cdot y = 1$\n$a\\cdot x = 1-m\\cdot y \\equiv 1 \\pmod m$\n$x$ 是 $a$ 对 $m$ 的逆元，问题转化为求方程 $a\\cdot x + m\\cdot y = 1$ 的正整数解\n$\\gcd(a,m) = 1$ 方程必有解，扩展欧几里得算法跑一下方程，求出 $x$ 再模 $p$ 处理\n复杂度 $\\mathcal{O}(\\log_2^n)$\n1int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) 2{ 3 if(!b) { x = 1; y = 0; return a; } 4 int g = exgcd(b, a%b, y, x); 5 y -= a/b*x; 6 return g; 7} 费马小定理 $\\tau(p)=2,\\ \\gcd(a,p) =1 \\implies a^{p-1}\\equiv 1 \\pmod p$\n$a*a^{p-2} \\equiv 1\\pmod p,\\ a$ 在模 $p$ 下的逆元为 $a^{p-2}$\n快速幂求 $a^{p-2}$ 即可\n复杂度 $\\mathcal{O}(\\log_2^n)$\n1int qp(int a, int b, int p) //qp = quick power 2{ 3 if(!b) return 1; 4 if(b\u0026amp;1) return a*qp(a*a%p, b\u0026gt;\u0026gt;1, p)%p; 5 else return qp(a*a%p, b\u0026gt;\u0026gt;1, p)%p; 6} 7int ie = qp(a, p-2, p); //ie = inverse element Fermat-Euler 定理 $\\gcd(a,m) = 1$ 时 $a^{\\varphi(m)} \\equiv 1 \\pmod m$\n所以 $a^{\\varphi(m)-1}$ 是 $a$ 在模 $m$ 下的逆元\n需要求 $\\varphi(m)$，再用快速幂求 $a^{\\varphi(m)-1}$\n不推荐\n线性递推 求 $\\forall{a},a\\in[1,p-1]$ ，模 $p$ 的逆元\n令 $ax + b = p;\\ b\\cdot b^{-1} \\equiv 1 \\pmod p$\n$\\because b = p-ax$\n$\\therefore (p-ax)\\cdot b^{-1} \\equiv 1 \\pmod p \\implies a\\cdot(-x\\cdot b^{-1}) \\equiv 1 \\pmod p$\n$\\therefore a^{-1}\\equiv (-x\\cdot b^{-1}) \\equiv (p-x)\\cdot b^{-1} \\pmod p$\n$a \u0026gt; b$ 直接动态规划扫一遍就好了\n在计算机中 $b$ 表示为 p%a，$x$ 表示为 p/a\n复杂度 $\\mathcal{O}(n)$\n1int inv[p] = {0, 1}; //inv = inverse element 2for(int i = 2; i \u0026lt; p; i++){ 3 inv[i] = (p-p/i) * inv[p%i] % p; 4} ","date":"2021-09-04","img":"","permalink":"/zh-cn/posts/%E9%80%86%E5%85%83/","series":null,"tags":["逆元"],"title":"逆元"}]